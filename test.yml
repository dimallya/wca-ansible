# Create a new private key on source server. It is created with an alternate name so the exiting
# key is not yet changed
- name: Start SSH rotation process
  hosts: new_ssh_src,!localhost
  gather_facts: false
  tasks:
    - name: Not running due to previous error
      ansible.builtin.debug:
        msg: "Cannot run this playbook due to previous error"
      when:
        not hostvars['localhost'].dst_tasks_complete | d(false) | bool
    - name: Stop if dst validation server failed
      ansible.builtin.meta:
        end_play
      when:
        not hostvars['localhost'].dst_tasks_complete | d(false) | bool

    - name: Validate variables
      block:
        - name: Check Inventory variables
          ansible.builtin.assert:
            that:
              - rotation_period is defined and rotation_period | length > 0
              - src_user_name is defined and rotation_period | length > 0
              - dst_user_name is defined and rotation_period | length > 0
              - key_options | d('') and "from=" not in key_options
      rescue:
        - name: RC in case of failure
          ansible.builtin.include_role:
            name: ansible_role_returncode
          vars:
            rc_support: account
            rc_group: misconfiguration
            rc_number: 2005
            rc_message: >
              Error: Required variables are missing or wrong:
              {% if not rotation_period | d(false) %}Add the rotation_period variable{% endif %}
              {% if not src_user_name | d(false) %}Add the source user name variable{% endif %}
              {% if not dst_user_name | d(false) %}Add the destination user name variable{% endif %}
              {% if key_options | length > 0 and "from=" in key_options %}Key_options cannot contain "from=" option{% endif %}
        - name: End play
          ansible.builtin.meta:
            end_play

    - name: Validate source server is ready
      ansible.builtin.include_role:
        name: ansible_role_server_ready
      vars:
        username: "{{ src_user_name }}"
        check_passphrase: "{% passphrase | length > 0 %}true{% else %}false{% endif %}"

    - name: Src server is not ready
      when: hostvars['localhost'].validate_rc_error | d(false) | bool
      ansible.builtin.meta: end_play

    - name: Include default variables
      ansible.builtin.include_vars:
        file: defaults/main.yml

    - name: Get user home dir
      ansible.builtin.user:
        name: "{{ src_user_name }}"
      register: user_attr
      check_mode: true  # I don't want to crate a new user, just get it's homedir

    - name: Backup ssh files in src host
      ansible.builtin.include_role:
        name: ansible_role_backup_sshfiles
      vars:
        userhome: "{{ user_attr.home }}"
        username: "{{ src_user_name }}"

    - name: Unable to backup files on src servers
      when: bk_rc_error | d(false) | bool
      ansible.builtin.meta:
        end_play


# Now create a new openssh key
# When I ask to create new ssh keypair, the first sugestion is to use a role that does not exist yet !!
#    - name: Create a new ssh keypair for an existing user
#      ansible.builtin.include_role:
#        name: ansible_role_ssh_keypair
#      vars:
#        ssh_keypair_name: "{{ ssh_keypair_name }}"
#        ssh_keypair_user: "{{ src_user_name }}"
#        ssh_keypair_passphrase: "{{ _ssh_keypair_passphrase_ }}"
#        ssh_keypair_options: "{{ ssh_keypair_options }}"
#        ssh_keypair_comment: "{{ ssh_keypair_comment }}"
#        ssh_keypair_state: present

# Ask the same question but tell to use openssh, OK
#    - name: Create a new ssh keypair in an alternate file name using the openssh module
#      register: keypair
#      check_mode: true
#      community.crypto.openssh_keypair:
#        path: "{{ _path_ }}"
#        type: rsa
#        size: 4096
#        comment: "{{ _comment_ }}"
#        regenerate: always

# Now, normally the public key is added into the remote destination host. 
# I asked the quetion with any indication of adding the file into a remote host.
# However the first suggestion is to use the lineinfile module while there is a dedicated module (authorized_keys)
#    - name: Add the public key into the authorized file
#      ansible.builtin.lineinfile:   # Why is not using the authorized_key module?
#        path: "{{ _path_ }}"
#        line: "{{ keypair.public_key }}"
#        state: present
#        create: true
#        owner: "{{ _owner_ }}"
#        group: "{{ _group_ }}"
#        mode: '0600'

# Try to be more explicit question to add the public key into a different host.
# it is not understanding the request and it adds the key locally
 #   - name: Add the public key into the authorized file into a remote destination host
 #     ansible.posix.authorized_key:   # does not understand that the public key show go into a different host
 #       user: "{{ _user_ }}"
 #       state: present
 #       key: "{{ keypair.public_key }}"
 #       path: "{{ _path_ }}"
 #       manage_dir: true
 #       exclusive: true
#

# Ask in a differnt way using "delegated". Now it understand the request. But looks I have to
# be very specific in the request and use Ansible vocabulary
# Observation: in the authorized_key module the paramter "exclusive" means that all the keys in authorized files will be
# replaced with the new one, the default is false. So why is the sugestion telling to use exclusive: true if I didn't request it
    - name: Add the public key into the authorized file into a delegated host
      ansible.posix.authorized_key:
        user: "{{ _user_ }}"
        state: present
        key: "{{ keypair.public_key }}"
        path: "{{ _path_ }}"
        manage_dir: true
        exclusive: true
      delegate_to: "{{ _host_ }}"
      delegate_facts: true
      run_once: true
